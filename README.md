# hh-school-search

## Реализованные возможности

**Основные задания:**
1. Индексация
2. Поиск

Возможность явного указания пути к индексу была намеренно исключена ввиду сложной структуры файлов, однако имеется возможность вручную редактировать, копировать, заменять эти файлы с помощью нативных средств ОС,
а также пересоздать их с помощью специальных команд. Подробнее описано в следующих разделах.

**Дополнительные задания:**
1. Операторы AND и NOT (NOT реализован в виде бинарного оператора, исключающего из результатов левого операнда результаты правого операнда - как разность множеств).
2. Фразовые запросы (они же - c ограничением расстояния). Синтаксис: `<< term1 term2 ... >>` (двойные угловые скобки, как подобие кавычек).
В качестве результата запрос возвращает первый токен удовлетворяющей фразы в документе.
Поддерживается символ "любого слова": `<< term1 * term3 >>`. Стоп-слова в запросе не поддерживаются, но их положение учитывается в самом документе при поиске.
Пример: `<< Marina * * Diamond >>` => "Marina and the Diamond", "Marina Developer in Diamond", ...
3. Применена оптимизация по нахождению пересечения множеств (см. Также реализовано)
4. ENTRY_OR: OR с задаваемым минимальным количеством вхождений. Синтаксис: `<limit>[<term|subQuery> <term|subQuery> ...]`.
Пример из задания: `2[java scala kotlin]`.
5. *(От себя):* Вложенные подзапросы и приоритет операций (круглые скобки).
Примеры: `Developer AND (C# OR C++)`, `3[белый (серый NOT (гусь OR утка)) <<из ржаной муки>> черный] AND (хлеб OR булка)`.
   
**Также реализовано:**
1. Работа со стоп-словами, знаками препинания, специальными терминами (включающими в себя знаки препинания, как "C++").
2. Оптимизация: инвертированный индекс по токенам позволяет находить конкретное место в документе, удовлетворяющее запросу.
3. Оптимизация: инвертированный индекс по документам позволяет быстрее находить пересечение по документам (используется в AND, ENTRY_OR, NOT), не выполняя distinct над токенами.
4. Оптимизация: операция пересечения (AND) выполняется в порядке увеличения результатов, удовлетворяющих отдельным операндам пересечения. Результат: меньшее число проверок и операций добавления/удаления.
   
**Примечания:**
1. OR должен быть явно указан между операндами (сделано так с перспективой лучшего анализа и ранжирования. Например, понимание ".NET Framework" в первую очередь как целого терма).
2. Фразовый запрос не может содержать подзапросов, только термы или `*` через пробел.
3. Использование стоп-слов в запросах не запрещается, но поиск ведется по термам, из которых таковые исключены, следовательно для такого операнда не найдется удовлетворяющих токенов, о чем появляется предупреждение при попытке выполнить такой запрос. 

## Сборка и запуск

1. Сборка в среде IntelliJ IDEA: `Вкладка 'Maven' > package`
2. Скопируйте файл `hh-school-search-1.0-SNAPSHOT-jar-with-dependencies.jar` в удобную директорию
3. Инициализация рабочей директории (файлы ресурсов): `java -jar hh-school-search-1.0-SNAPSHOT-jar-with-dependencies.jar init`
4. Индексация: `java -jar hh-school-search-1.0-SNAPSHOT-jar-with-dependencies.jar index <путь к файлу>`
5. Поиск: `java -jar hh-school-search-1.0-SNAPSHOT-jar-with-dependencies.jar search "<запрос>"`

* Инициализация (восстановление по умолчанию) только файлов словарей: `java -jar hh-school-search-1.0-SNAPSHOT-jar-with-dependencies.jar init dict`
* Инициализация (восстановление по умолчанию) только файлов индекса: `java -jar hh-school-search-1.0-SNAPSHOT-jar-with-dependencies.jar init index` 

## Настройка ресурсов

Пакет jar создает и использует файлы словарей и индекса в папке `./res`.
Вы можете изменить их в любом удобном текстовом редакторе.

В папке репозитория [`src/main/resources`](src/main/resources) расположены файлы, содержащие словарь знаков пунктуации, специальных терминов, стоп-слов и т.п., встраиваемые в пакет jar и генерируемые по умолчанию командой `init`.

Вы можете использовать комментарии в этих файлах.
Начало комментария = (начало строки или пробел, решетка, не решетка); конец комментария = конец строки (regex: `/(^|\s)#[^#].*$/`).

## Дз по поиску 

Реализовать свой простой поиск на java, который может работать в 2 режимах: 

1. Индексация: на вход подаётся название файла(директории) индекса и исходный файл, где каждая строка является отдельным документом в индексе, и происходит построение индекса, который записывается в файл(директорию). 
2. Поиск: на вход подаётся название файла индекса и запрос, на выходе получаем список документов подходящих под этот запрос.

Начать можно с написания наивной реализации инвертированного индекса и запросов по одному слову. В итоге должна получиться jar-ка, которая может работать в 2 режимах. Сдавать в виде PR к этому репозиторию с инструкцией для сборки и запуска, и списком что было реализованно. 

## Доп. задания (не обязательно, в порядке усложнения): 
* написать реализацию запросов AND и NOT
* написать реализацию фразовых запросов
* применить оптимизации при построении индекса из лекции
* написать реализацию OR с задаваемым минимальным количеством вхождений (пример: есть запрос java OR scala OR kotlin, мы хотим все документы где есть минимум 2 слова)

## Срок сдачи

31.01.2019 23:59

## UPD 1

не использовать сторонние библиотеки полнотекста (lucene)
